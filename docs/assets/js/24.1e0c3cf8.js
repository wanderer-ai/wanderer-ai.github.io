(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{379:function(e,t,a){"use strict";a.r(t);var s=a(42),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"working-with-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#working-with-data"}},[e._v("#")]),e._v(" Working with data")]),e._v(" "),a("p",[e._v("There are two basic forms of data in this system. Static data and lifecycle data.")]),e._v(" "),a("p",[a("code",[e._v("Static data")]),e._v(" is all of the data that you can create and maintain with the builder. This includes the nodes with all their values ​​and all edges with all their values. It is all data that exist in a finished flow file.")]),e._v(" "),a("p",[a("code",[e._v("Lifecycle data")]),e._v(", on the other hand, is all data that is generated automatically and dynamically when the bot is running. This can be the user's answers to questions but also the different states of nodes during the conversation. Only this data can be exchanged between nodes.")]),e._v(" "),a("p",[e._v("Since only lifecycle data can be used dynamically inside nodes, this chapter is all about that.")]),e._v(" "),a("h2",{attrs:{id:"exchange-lifecycle-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exchange-lifecycle-data"}},[e._v("#")]),e._v(" Exchange lifecycle data")]),e._v(" "),a("p",[e._v("Certain nodes generate certain data. In order to be able to use this data in other nodes, this "),a("code",[e._v("data must first be sent there")]),e._v('. You cannot access all data of the flow within a node. This is important to understand as it is a fundamental part of the strict design pattern. Data can only be transferred from one node to another within "leads to" edges. Access is not possible without this transfer.')]),e._v(" "),a("p",[e._v("For example, if you want to use the value of an input field of a suggestion inside a message node, you have to connect both nodes together. The edge must point from the suggestion to the message and the data must be exposed within the edge. Each edge can only transmit one value at a time. If you want to transfer several values, use several edges in parallel.")]),e._v(" "),a("p",[e._v("You can also give the transferred values ​​a different name. This will help you keep them apart in the destination node.")]),e._v(" "),a("h2",{attrs:{id:"data-reactivity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-reactivity"}},[e._v("#")]),e._v(" Data reactivity")]),e._v(" "),a("p",[e._v("If you edit fields in the Builder, you will find that the output of the chat also changes immediately in most cases. That's because "),a("code",[e._v("the data is reactive")]),e._v(". For example, if you are editing the text of a message, you can see how the text changes in chat.")]),e._v(" "),a("p",[e._v("Static data is always reactive. This means that you will always see changes to static data immediately inside the builder. However, this only makes sense inside the Builder. People who only use the finished chat cannot change this data.")]),e._v(" "),a("p",[e._v("Lifecycle data generated during the chat, on the other hand, is not always reactive because that doesn't always make sense. So you don't want the chat history to change, for example, if the user repeats a question and answers it differently. That is why the lifecycle data is frozen during the chat for each message. Active questions and suggested answers, however, remain fully reactive. For example, questions can change their text while an interaction is offered because the underlying lifecycle data has changed.")])])}),[],!1,null,null,null);t.default=i.exports}}]);